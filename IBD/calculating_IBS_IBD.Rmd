---
title: "Calculating IBS & IBD"
author: "Nick Brazeau, Sophie Berube, Izzy Routledge, & Abebe Fola"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  html_document:
    theme: readable
    highlight: tango
    code_folding: hide
    toc: yes
    toc_float:
      collapsed: no
      smooth_scroll: no
    toc_depth: 2
    number_sections: yes
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = T, warning = F, message = F,
                      fig.align = 'center', fig.keep = 'all')
```

<!-- Here we style out button a little bit -->

```{=html}
<style>
.showopt {
background-color: #004c93;
color: #FFFFFF;
width: 100px;
height: 20px;
text-align: center;
vertical-align: middle !important;
border-radius: 8px;
float:right;
}

.showopt:hover {
background-color: #dfe4f2;
color: #004c93;
}

</style>
```
<!--Include script for hiding output chunks-->

```{=html}
<script src="misc/hideOutput.js"></script>
```
# Dependencies for Practical {.unnumbered}

Please copy and paste the below code chunk in it's entirety to your console to download R package libraries needed for this practical. If you are having trouble installing any of the R packages, please ask an instructor for a pre-loaded flash drive.

```{r, echo=T}
deps <- c("tidyverse", "vcfR", "MIPanalyzer", "hmmibdr", "sf", "tidygraph", "ggraph")
deps <- !sapply(deps, function(x){x %in% installed.packages()[,1]} )
if(any(deps)) {
  if(deps["hmmibdr"]) {
    if (!"remotes" %in% installed.packages()[,1]){
      install.packages("remotes")
    }
    remotes::install_github("OJWatson/hmmibdr")
    deps <- deps[names(deps) != "hmmibdr"]
  } else if(deps["MIPanalyzer"]) {
    if (!"remotes" %in% installed.packages()[,1]){
      install.packages("remotes")
    }
    remotes::install_github("mrc-ide/MIPanalyzer")
    deps <- deps[names(deps) != "MIPanalyzer"]
  } else {
    install.packages(names(deps)[deps])
  }
}

```

Please now load all of those libraries into this session using the code chunk below. Please copy and paste it in its entirety.

```{r, echo=T}
library(tidyverse)
library(vcfR)
library(hmmibdr)
library(sf)
library(tidygraph)
library(ggraph)
library(cowplot)
```

Finally, please source (*i.e.* load) the file called `utils.r` that is stored under the `IBD/R` directory. If you are using the `IBD.Rproj` environment, you can just run `source("R/utils.R")` as below. Or if you are running from a different environment or working directory (`getwd()`), use the `file.choose` function to help locate the file.

```{r}
source("R/utils.R")
```

# Introduction
## Useful Definitions {.unnumbered}
_**Definition:** An allele is the state of a particular genetic locus or sequence that is inherited between parents and offspring._ <br>
_**Definition:** A locus is a fixed position on a chromosome where a particular genetic marker is located._ <br>
_**Definition:** Sequencing data consists of sequences of DNA obtained from a DNA sequencing reaction_ <br>
_**Definition:** Complexity of infection, or multiplicity of infection, is a measure of the number of different malaria parasite clones in an individual sample._ <br>
_**Definition:** A monoclonal malaria infection contains one parasite strain, or "genome" (complexity of infection [COI] = 1), while a polyclonal infection contains more than one parasite strain (COI > 1)._ <br>
_**Definition:** A deme is a local population that has individuals that interbreed and share genetic material._ <br>
<br>
<br>

## Relatedness Overview {.unnumbered}

During prior sessions, you have explored how to estimate relationships based on levels of population diversity, structure, and connectivity. In this practical, we will focus on between-parasite, or pairwise, measures of genetic relatedness. These are more "individual" focused measures of relatedness versus population, or deme, focused measures of relatedness.
<br>
There are two mains ways to estimate relatedness among individuals: identity by descent (IBD) or Time to Most Recent Common Ancestor (TMRCA) (see [Speed & Balding 2015](https://pubmed.ncbi.nlm.nih.gov/25404112/) for further discussion). We will be focusing on IBD, which leverages recombination to detect recent common inheritance of genetic material, or genetic relatedness.
<br>
Remember, that recombination and random segregation occurs with homologous chromosome pairing during the process of meiosis. This means that "maternal" and "paternal" genetic material is exchanged to create new "daughter" cells with unique genetic material (e.g. a new, unique haplotype).

<p align="center">
![](https://raw.githubusercontent.com/mrc-ide/AMMS2022/master/IBD/R_ignore/images/Meiosis.jpeg){height="300px"}
</p>


<br>
<br>

Applying this concept to malaria in the schematic below, a single mosquito has bitten two different individuals infected with a single strain of the malaria parasite, resulting in a superinfection. The two strains (red vs purple) then undergo recombination in the mosquito midgut and produce progeny that are siblings and expected to share half of their genomes on average. 
<br>
From a population genetics perspective, this exchange of genetic material via recombination can be leveraged to detect strong signals of genetic relatedness between individuals. For example, moving further along in the schematic, the mosquito bites three new hosts and transfers a new "daughter" parasites to the susceptible host respectively (*N.B.*, since only a single strain was transmitted, no cotransmission infections resulted despite the potential). The pedigree on the right shows two of the parasite siblings and highlights how much of their genome was inherited from the same parent in the same genomic location. 
<br> 
As a result, one way to conceptualize the genome is as blocks, or segments, that are joined together, where each block has its own unique ancestral history. We will explore the concept that as time increases, or there is an increasing number of generations generations, IBD blocks become smaller  (*i.e.* as the number of recombination events increases, blocks are broken into smaller and smaller bits).
<br>
<br>

<p align="center">
![](https://raw.githubusercontent.com/mrc-ide/AMMS2022/master/IBD/R_ignore/images/ibdsiblings.png){width="500px"}
</p>


<br>
<br>
<br>

## IBS/IBD Overview {.unnumbered}

As described in the lecture, we can consider pairwise relatedness by determining if the genetic sequence at a give position in the genome, a loci, between two parasites is identical (e.g. the same allele). We can either simply measure the number of sites with identical alleles between two individuals, termed identity by state (IBS), or, we can use statistical models to determine if identical alleles and "blocks" of the genome were likely to be inherited from a common ancestor, termed identity by descent (IBD). It is important to note the differences between IBS and IBD: IBS refers to the "state" or realization of the allele at a loci and can be the result of numerous factors other than ancestry (e.g. selection, drift, structure, chance). In contrast, IBD solely refers to inherited genetic material, which follow specific patterns relevant to public health that we will explore below. The differences between IBS and IBD are visualized in the schematic below, where sites may be IBS but not IBD, whilst all sites that are IBD are IBS.

<p align="center">
![](https://raw.githubusercontent.com/mrc-ide/AMMS2022/master/IBD/R_ignore/images/ibd_vs_ibs.png){width="300px"}
</p>

### IBState {.unnumbered}

Identity by state (IBS) is the proportion of identical loci divided by all measured loci in the genome between two parasites: $\mbox{parasite}_a$ and $\mbox{parasite}_b$, such that: $$IBS= \frac{\mbox{Shared loci}_{ab}}{\mbox{Number of loci}}$$

### IBDescent {.unnumbered}

Identity by Descent (IBD) is more complicated to calculate than IBS and requires statistical modeling in order to account for recombination and population allele frequencies. The most common statistical model used is called a Hidden Markov Model (see the *Further Reading* section for recommended sources).
<br>
<br>
_**Conceptual Question:** What are some reasons that parasite pairs may be IBS but not IBD? What is a method that you have already learned that would increase your suspicion for IBS but not IBD_
<br>
_**Answer:** Population allele frequencies (if an allele is very common or fixed in a population, it does not contain as much information to distinguish between IBD and IBS)_
<br>
<br>
_**Conceptual Question:** Are biallelic markers (genotypic positions with two alleles, or possibilities) or multiallelic markers (genotypic positions with multiple alleles) more informative for IBS/IBD. Would you suspect a site with 20 alleles to be identical by chance?_
<br>
_**Answer:** Multiallelic has more information_

### IBD Programs {.unnumbered}
<!-- https://www.tablesgenerator.com/markdown_tables -->
Below is a table of pros-cons-details of various IBD programs specified for malaria that have been peer-reviewed as of August 5, 2022. 
<br>
<br>
<br>

| **Program** 	| **Pros** 	| **Cons** 	| **Details** 	|
|---	|---	|---	|---	|
| [Inbreeding estimation](https://pubmed.ncbi.nlm.nih.gov/32355199/) 	| + Fast 	| + Assumes independent loci 	|  Model is not considering recombination blocks (backbone of IBD) 	|
| [hmmIBD](https://github.com/glipsnort/hmmIBD) 	| + Fast <br><br>+ Easy to use <br><br>+ Statistically robust <br><br>+ Cannonical program for malaria ibd <br> 	| + Specified for monoclonals 	|  Users can use in polyclonal samples, but is misspecified under model and results are typically conservative estimates of IBD 	|
| [isoRelate](https://github.com/bahlolab/isoRelate) 	| + Statistically robust <br><br>+ Handles polyclonals <br><br>+ Statistical testing for "important" loci <br> 	| + Can become computationally intensive  	|  Model assumes a "diploid" state for COI > 1, and thus makes a simplifying assumption about polyclonality 	|
| [DeploidIBD](https://github.com/DEploid-dev/DEploid) 	| + Statistically robust <br><br>+ Handles polyclonals <br><br>+ Phased sample results <br><br>+ Within-sample estimates of IBD <br> 	| + Computationally intensive 	| Model phases polyclonal samples into monoclonal samples (_i.e._ a sample with COI = 2 becomes two new phased strains: smpl1.1, smpl1.2). As part of phasing, program provides within-sample IBD. From phased sample results, users can use any existing IBD program (`hmmIBD`, `refinedIBD`, etc). Program's primary goal is phasing with within-IBD estimates provided as a "bonus". 	|

<br>
<br>

# Overview of Data {.unnumbered}
This data was simulated using a simple malaria model that takes into account spatial relationships, complexity of infection (COI), and population size under a Wright-Fisher model: [PolySimIBD](https://github.com/nickbrazeau/polySimIBD). Later, you will have an opportunity to interact with this simulator to further refine your intuition for IBS/IBD in the _Self Exploration_ section.
<br>
For this practical, we have simulated five populations, or demes: A-E. The demes were simulated to have the same number of people, or hosts; however, we have randomly selected five individuals from each deme to undergo molecular surveillance and be "sequenced" (_i.e._ in real life, you may select five participants from a village to donate whole-blood vs collecting blood from every individual in the village). The demes have varying intensity of transmission, or incidence, as indicated by the spectrum of yellow-red in the schematic legend. In addition, we expect for mosquitoes to migrate between the demes with respect to how far the demes are from each other (_i.e._ C and D are close, therefore we may expect mosquitoes to transport parasites between those demes more frequently than from A to D). Finally, we hypothesize that the ocean between demes A-D and E is a barrier to any transmission from the "mainland" to the "island" (_i.e._ we expect mainland parasites to be distinct from island parasites). In summary, the data consists of:    

- Five demes (4 mainland, 1 island)   
- Locations are known for each deme    
- Five random samples from each deme
- Incidence as estimated by mean COI per deme\*

_\*As discussed yesterday, COI is a poor measure of incidence in the real world. For our model, it is quite correlated (in expectation) and will be used as a proxy here._
<br>

<p align="center">
![](https://raw.githubusercontent.com/mrc-ide/AMMS2022/master/IBD/R_ignore/images/sim_deme_schematic.png){width="500px"}
</p>

# Practical Goals {.unnumbered}

By the end of this practical, you should understand the following concepts:    

+ IBS is straightforward to calculate but can produce biased estimates of relatedness (*i.e.* does not necessarily reflect ancestry and is affected by population level allele frequencies)   
+ IBD captures recent relatedness, useful for determining transmission events, transmission intensity, importation, and corridors of gene flow   
- Therefore, IBS/IBD can measure connectivity on spatial-temporal scales relevant to malaria control and elimination efforts      
+ IBD should decay with distance (isolation by distance) and time; when it does not, interesting things may be happening  

------------------------------------------------------------------------

# Importing Data

Here, we will use the `vcfR` [package](https://knausb.github.io/vcfR_documentation/) to read in our variant call file (VCF) that contains fifty biallelic SNPs for our twenty-five individuals across our five populations (A, B, C, D, E; *individuals named* A1-5, B1-5, ...).

Using the skills that you acquired yesterday, read in the VCF from our data folder that you downloaded from Github: `data/simulated_ibd.vcf.gz`. If you are having trouble locating the file on your computer, please type `file.choose` into your console for an interactive option to locate the file. Name the object (the vcf file you are reading in) "vcf" for simplicity.

```{r}
# participants DO NOT need to include the quiet bit
vcf <- quiet(vcfR::read.vcfR("data/simulated_ibd.vcf.gz"))
```

## Initial QC
As is always good practice, we can check our VCF for missing data and confirm it has the number of SNPs and samples that we expect. Explore the details and inner-workings of our new VCF to get a sense if it is trustworthy (_i.e._ does the data look reasonable? Is there anything strange in the INFO column?). In addition, use the `extract.gt` function from the vcfR package to pull out the allele depth (first record) for your new VCF. Now plot that allele depth as an initial data exploration using the `heatmap.bp` function from the `vcfR` package.

```{r}
ad <- vcfR::extract.gt(vcf, element = "AD", as.numeric = T)
vcfR::heatmap.bp(ad)
```

_**Conceptual Question:** Is above plot consistent w/ a high quality VCF?_
<br>
_**Answer:** While it does look quality, there are several features that would make you question if it was real data:_    
- All of the REF/ALT basepair allele calls are "N" missing  
- All of the loci allele depths are 100  
- The QUALTIY column is all the same  
<br>
<br>
This data was simulated, and thus, lacks many of the "real world" appearances of a VCF generated from real sequencing data. It is always valuable to manually look at the VCF (or portions of it is large) to determine it's validity before starting analyses (for those interested or with time at the end of the tutorial, please see the _Advanced Section_ for command line manipulations of the VCF)!
<br>

## Exploring Hets
Here, we will explore the number of heteerzygous genotype calls we have per sample in our VCF.
```{r}
# extract and tidy
gt <- vcfR::extract.gt(vcf, element = "GT")
gt <- dplyr::bind_cols("chrom" = vcfR::getCHROM(vcf), "pos" = vcfR::getPOS(vcf), gt)
gt %>%
  tibble::as_tibble() %>%
  tidyr::pivot_longer(., cols = !c("chrom", "pos")) %>%
  dplyr::mutate(ishet = dplyr::case_when(value == "0/0" ~ F,
                                         value == "0/1" ~ T,
                                         value == "1/1" ~ F)) %>%
  dplyr::group_by(name) %>%
  dplyr::summarise(
    propHet = mean(ishet)) %>%
  ggplot() +
  geom_point(aes(x = name, y = propHet)) +
  ylab("Proportion of Sample that is Het") +
  xlab("") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.75, hjust = 0.5))
```

_**Conceptual Question:** Do you recognize any pattern in heterozygote calls with respect to demes? How does this relate to the polyclonality lesson yesterday?_
<br>
_**Answer:** Demes with higher transmission intensity have more heterozygote calls_
<br>
<br>

# Intuition

## Visualizing Recombination

One approach of conceptualizing recombination is as a "stick breaking" process. For example, you can imagine that you have two sticks that are identical (_i.e._ twins, or clonal infections). In each new generation, you have to randomly break your stick at some point along its length. You then take your pieces of stick and flip a coin to determine if it will remain the same ("original") or inherit genetic material ("new"). Use the `view_recombo` (loaded from `R/utils.R`) to appreciate that as time increase, recombination block length decreases.

For example, you could run the function with the following generational times.


```{r, eval=F}
view_recombo(generations_apart = 0)
view_recombo(generations_apart = 1)
view_recombo(generations_apart = 2)
view_recombo(generations_apart = 3)
view_recombo(generations_apart = 5)
view_recombo(generations_apart = 10)
view_recombo(generations_apart = 20)
```
```{r, echo=F}
view_recombo(generations_apart = 20) +
  labs(title = "Breakdown of Clonal Material \n over 20 Generations",
       caption = "Note, new material is not necessarily IBD")

```
_**Conceptual Question:** How does the amount of "clonal" genetic material change, or amount of the genome that is identical, change between the paired samples as we increase the number of generations that separates them?_
<br>
_**Answer:** Decreases_
<br>
<br>

# Calculations

### Internal Data Manipulation

Here, we are going to convert our _vcf_ object that we read in with the `vcfR` package to a _mip_ object in order to later use the [`MIPAnalyzer` Package](https://github.com/mrc-ide/MIPanalyzer/tree/master/R) and the maximum likelihood estimator of IBD from [Verity et al. 2020](https://pubmed.ncbi.nlm.nih.gov/32355199/). This is purely for convenience and is not changing the underlying data in the vcf.

```{r}
mipvcf <- MIPanalyzer::vcf2mipanalyzer_biallelic(vcfR = vcf)
```

## Identity by State
_**Challenge:** Pick two samples from your VCF and write your own function to calculate IBS between the pair_.
<br>
_**Example Answer:** (unfold code)_.
```{r, eval=F}
# pick two samples
simpleIBS <- function(vcfRobj, smpl1name, smpl2name) {
  # extract GT information from vcf
  gt <- vcfR::extract.gt(vcfRobj, element = "GT")
  # subset to our samples, these are now vectors
  smpl1 <- gt[,smpl1name]
  smpl2 <- gt[,smpl2name]
  # evaluate if each element in vector is the same or different = Boolean result
  # take mean to get a proportion (binomial mean)
  ibsprop <- mean(smpl1 == smpl2)
  return(ibsprop)
}

simpleIBS(vcfRobj = vcf, smpl1name = "A1", smpl2name = "D1")

```
<br>
<br>

### Run Package IBS
Next, we will use the IBS calculator from the `MIPAnalyzer` R package to calculate pairwise IBS for all combinations of samples in our simulated data. Please see the code below for ease of running the algorithm.  

```{r}
# get IBS
ibs <- MIPanalyzer::get_IBS_distance(x = mipvcf,
                                     ignore_het = FALSE,
                                     report_progress = FALSE)
```

#### Tidy Results
The function returns the data in a "wide" format or a [distance matrix](https://en.wikipedia.org/wiki/Distance_matrix). While this a perfectly acceptable format, it is not considered "tidy". We will perform some data munging below to transform the data into "long" format and make it more "tidy" for ease of use and plotting.

```{r}
# tidy result
colnames(ibs) <- rownames(ibs) <- colnames(vcf@gt)[2:ncol(vcf@gt)]

ibs_long <- broom::tidy(as.dist(ibs)) %>%  
  magrittr::set_colnames(c("p1", "p2", "ibsdist"))
```

#### Explore Results
It is always good practice to explore our results. Let's make a boxplot to explore the distribution of our calculated IBS results.
```{r}
# boxplot result
ibs_long %>%
  ggplot() +
  geom_boxplot(aes(y = ibsdist),
               outlier.colour = "red", outlier.shape=8,
               outlier.size=4) +
  ylab("IBS Values") +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank())

```
_**Conceptual Question:** Describe the distribution. Is this what you expected?_
<br>
<br>
<br>

## Identity by Descent
In this section, we will use two different "aglorithms" to calculate IBD. The first will be a maximum likelihood estimator that calculates the amount of "inbreeding" which approximates IBD (see [Verity et al. 2020]() for a mathematical description). Next, we will use a hidden Markov model from the R-package `hmmIBDR`, which is a wrapper for the original `hmmIBD` algorithm (for a full mathematical description of `hmmIBD` see [Schaffner & Taylor 2018](https://pubmed.ncbi.nlm.nih.gov/29764422/)).

#### MLE IBD
As above, we will use `MIPAnalyzer` R package to calculate pairwise IBD for all combinations of samples in our simulated data. Please see the code below for ease of running the algorithm. We are then going to similarly tidy the data from "wide" to "long" format.
```{r}
#......................
# MLE IBD
#......................
ibd <- MIPanalyzer::inbreeding_mle(x = mipvcf,
                                   f = seq(0.01, 0.99, 0.01),
                                   ignore_het = FALSE,
                                   report_progress = FALSE)
# tidy result
diag(ibd$mle) <- 1
colnames(ibd$mle) <- rownames(ibd$mle) <- colnames(vcf@gt)[2:ncol(vcf@gt)]

ibd_mle_long <- broom::tidy(as.dist(t(ibd$mle))) %>%  # note, mipanalyzer returns upper triangle
  magrittr::set_colnames(c("p1", "p2", "malecotf"))
```

#### Explore Results
We always explore our results!
```{r}
# boxplot result
ibd_mle_long %>%
  ggplot() +
  geom_boxplot(aes(y = malecotf),
               outlier.colour = "red", outlier.shape=8,
               outlier.size=4) +
  ylab("IBD MLE Values") +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank())

```

_**Conceptual Question:** Describe the MLE distribution. Is this what you expected?_
<br>
<br>
<br>


#### HMM IBD
As stated above, we will use `hmmIBDR` R package [wrapper](https://github.com/OJWatson/hmmibdr) to calculate pairwise IBD. Please see the code belwo for ease of running the algorithm. Note, we are going to have to do some data munging and writing of input file in order to use the `hmmIBD` [program](https://github.com/glipsnort/hmmIBD).    
<br>
_**To Munge**_: Extract the `GT` calls from the VCF and converrt them to _0_ for homozygous referent calls, _1_ for homozygous alternative calls, and _-1_ for heterozgous calls. Then add a column for chromosome and position (columns one and two, respectively) to your newly created genotype matrix. Explore the [hmmIBD documentation](https://github.com/glipsnort/hmmIBD) for a justification of this munging. Separately, you will need to create a file that contains the population allele frequencies. For each sample, calculate the referent-within sample allele frequencies and then take the mean across samples per locus. 

_**Caveat**: The `hmmIBD` algorithm assumes that all samples are monoclonal. As a result, it does not accept heterozygote calls natively. As a user, we have two options: (1) to set those heterozygote calls to missing (a conservative approach), or (2) make a strong assumption about what a heterozygote call means (an aggressive approach). Here, I have forced the samples to be monoclonal by estimating their within-sample allele frequencies and rounding to the nearest variant._

```{r}
#......................
# hmmIBD setup
#......................
# File of genotype data
ad <- vcfR::extract.gt(vcf, element = "AD")
dp <- vcfR::extract.gt(vcf, element = "DP", as.numeric = T)
altad <- vcfR::masplit(ad, record = 2, sort = F)
wsaf <- altad/dp
colnames(wsaf) <- colnames(vcf@gt)[2:ncol(vcf@gt)]
gt <- dplyr::bind_cols("chrom" = vcfR::getCHROM(vcf), "pos" = vcfR::getPOS(vcf), wsaf)
gtmat <- gt %>%
  tidyr::pivot_longer(., cols = !c("chrom", "pos")) %>%
  dplyr::mutate(chrom = 1,
                gthmm = round(value, 0)) %>%
  dplyr::select(-c("value")) %>%
  tidyr::pivot_wider(data = ., names_from = "name", values_from = "gthmm")
readr::write_tsv(x = gtmat, file = "data/gt_matrix_for_hmmIBD.txt",
                 col_names = T)

# File of allele frequencies for the sample population. Format: tab-delimited, no header, one variant per row. Line format: <chromosome (int)> <position (bp, int)> <allele 1 freq> <all 2 freq> [<all 3 freq>] ... The genotype and frequency files must contain exactly the same variants, in the same order. If no file is supplied, allele frequencies are calculated from the input data file.
altafvec <- rowMeans(wsaf, na.rm = T)
afmat <- dplyr::bind_cols("chrom" = vcfR::getCHROM(vcf),
                          "pos" = vcfR::getPOS(vcf),
                          1-altafvec, altafvec) %>%
  dplyr::mutate(chrom = 1)
readr::write_tsv(afmat, file = "data/af_matrix_for_hmmIBD.txt", col_names = F)

#......................
# hmmIBD run
#......................
tf <- tempfile(pattern = "output_simdat")
out <- hmmibdr::hmm_ibd(input_file = "data/gt_matrix_for_hmmIBD.txt",
                        allele_freqs =  "data/af_matrix_for_hmmIBD.txt",
                        rec_rate = 1e-2,
                        output_file = tf)

# hmmIBD tidy
ibd_hmm_long <- tibble::tibble(
  p1 = out$fract$sample1,
  p2 = out$fract$sample2,
  hmm = out$fract$fract_sites_IBD)


```

#### Explore Results
Again!
```{r}
# boxplot result
ibd_hmm_long %>%
  ggplot() +
  geom_boxplot(aes(y = hmm),
               outlier.colour = "red", outlier.shape=8,
               outlier.size=4) +
  ylab("IBD HMM Values") +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank())

```

_**Conceptual Question:** Describe the HMM distribution. Is this what you expected?_
<br>
<br>

#### Contrast MLE vs HMM
Make a plot comparing the MLE IBD vs the HMM IBD results.
```{r}
dplyr::left_join(ibd_mle_long, ibd_hmm_long, by = c("p1", "p2")) %>%
  ggplot() +
  geom_point(aes(x = hmm, y = malecotf)) +
  theme_bw() +
  labs(x = "IBD from HMM", y = "IBD from MLE")


```

_**Conceptual Question:** Why would these two results differ? Are there any differing assumptions made in the models?_
<br>
_**Example Answer:** Remember that `hmmIBD` assumes that samples are monoclonal. Therefore, heterozygote calls will break down IBD blocks rapidly under our simple "force" to monoclonal assumption_.
<br>
<br>

### Summary/Check-In
At this point, you should have created three result objects:      
  + *ibs_long*     
  + *ibd_mle_long*     
  + *ibd_hmm_long*     
If you are having computational trouble or time is a limiting factor, please see the `results/` directory, where you will be able to read in the results.


# Applied IBD
In this section, we will focus on the utility of IBS and IBD for realistic applications related to control and elimination efforts. For this section, we will focus on the MLE-IBD estimates (vs HMM-IBD estimates).

## IBS vs IBD
Compare IBS and IBD in a scatterplot.
```{r}
dplyr::left_join(ibs_long, ibd_mle_long, by = c("p1", "p2")) %>%
  ggplot() +
  geom_point(aes(x = malecotf, y = ibsdist)) +
  geom_smooth(aes(x = malecotf, y = ibsdist), method = "lm") +
  xlim(c(0,1)) + ylim(c(0,1)) +
  labs(x = "MLE-IBD Estimates", y = "IBS Distance") +
  theme_bw()

```

_**Conceptual Question:** How do the estimates of IBS and IBD differ. What is the smallest value for IBS versus IBD? Why may these be different?_
<br>
_**Answer:** IBS is affected by the population allele frequencies in a population and can overestimate relatedness when alleles are fixed in a population due to reasons other than inheritance (i.e. IBD = 0, IBS > 0.5, seen on the left-hand side of the plot). Fixation of alleles is particularly common in small populations due to genetic drift (as was the case in this simulation) or due to selection. As a result, although high values of IBS likely indicate high levels of relatedness, lower values of IBS are more difficult to interpret._

## IBD Distribution
Now, let's look at the distribution of our IBD estimates. In particular, we will focus in on the "tail" of the distribution (_i.e._ high values).
```{r}
mainplot <- ibd_mle_long %>%
  ggplot() +
  geom_histogram(aes(x=malecotf, y = (..count../sum(..count..))*100),
                 color = "#000000", fill = "#d9d9d9") +
  xlab("IBD") + ylab("frequency (%)") +
  theme_classic()

insetplot <- ibd_mle_long %>%
  ggplot() +
  geom_histogram(aes(x=malecotf, y = (..count../sum(..count..))*100),
                 color = "#000000", fill = "#d9d9d9") +
  xlab("IBD") + ylab("frequency (%)") +
  theme_classic() +
  coord_cartesian(xlim = c(0.5,1), ylim = c(0,0.8)) +
  theme_bw() +
  theme(panel.background = element_rect(fill = "transparent"),
        plot.background = element_rect(fill = "transparent"))
# cowplot
cowplot::ggdraw() +
  cowplot::draw_plot(mainplot, x = 0, y = 0, width = 1, height = 1, scale = 1) +
  cowplot::draw_plot(insetplot, x = 0.5, y= 0.3, width = 0.4, height = 0.4)

```
_**Conceptual Question:** How would you describe this distribution? Would you expect this many unrelated samples? What about the proportion of highly related pairs in the tail of the distribution?_
<br>
<br>

## Transmission Intensity
As we have seen from the recombination review at the beginning of the practical, as the number of recombination events increases, we expect for IBD due to decrease. As a result, in areas with higher transmission intensity, here modeled through differences in COI, we can expect for IBD to be less.

### Within-Deme IBD vs COI
By grouping samples together by their home demes, we can estimate the amount of inbreeding within a deme, or the within-deme IBD. Read in the `data/metadata.RDS` file and calculate the mean IBD by deme to get the within-deme IBD. Then plot the within-deme IBD versus simulated mean COI in that deme.
```{r}
mtdt <- readRDS("data/metadata.RDS")

#......................
# data munging
#......................
mtdt_x <- mtdt %>%
  dplyr::rename(p1 = smpl)
mtdt_y <- mtdt %>%
  dplyr::rename(p2 = smpl)
ibd_mle_long_mtdt <- dplyr::left_join(ibd_mle_long, mtdt_x, by = "p1") %>%
  dplyr::left_join(., mtdt_y, by = "p2") %>%
  rename_with(., ~gsub(".x", "_p1", .x, fixed = T)) %>%
  rename_with(., ~gsub(".y", "_p2", .x, fixed = T))
#......................
# plot within IBD
#......................
ibd_mle_long_mtdt %>%
  dplyr::filter(deme_p1 == deme_p2) %>%
  dplyr::group_by(deme_p1) %>%
  dplyr::summarise(
    withinIBD = mean(malecotf),
    meanCOI = mean(coimeans_p1)) %>%
  ggplot() +
  geom_point(aes(x = withinIBD, y = meanCOI)) +
  labs(x = "Within Deme IBD", y = "Simulated Mean COI",
       caption = "Remember, COI is a poor estimate of incidence. IBD is also affected by multiple factors, including randomness.") +
  theme_classic()

```
_**Conceptual Question:** Is there a correlation here between mean COI and within deme IBD?_
<br>
_**Answer:** No, but the lowest COI was associated with the greatest within deme IBD._
<br>
<br>
_**Conceptual Question:** Why did our expectation of the relationship of within-deme IBD and transmission intensity not match reality?_
<br>
_**Answer:** Our expectations do not always match realized data. There are also multiple confounding variables here, including: migration and incomplete sampling._
<br>
<br>

## Isolation by Distance
Next, we will explore the concept of isolation by distance, which is the theory that as pairs move further away in space, they should be less related (_i.e._ closer pairs are more likely to reproduce). This concept is based on spatial relationships, but can also be conceptualized as time (pairs that are separated by multiple generations of time are less likely to be related). Read in the `data/deme_gc_dist.RDS` object to calculate how IBD may decay over distances. Use groupings of:

```{r}
gcdist <- readRDS("data/deme_gc_dist.RDS")
ibd_mle_long_mtdt_dist <- dplyr::left_join(ibd_mle_long_mtdt, gcdist, by = c("deme_p1", "deme_p2")) %>%
  dplyr::mutate(distance = ifelse(is.na(distance), 0, distance))
ibd_mle_long_mtdt_dist$distance_cat <- cut(x = c(ibd_mle_long_mtdt_dist$distance),
                                           breaks = c(0, 1e-26,
                                                      seq(40, 120, by = 40),
                                                      Inf),
                                           right = F, #
                                           labels = c("Within", "40km", "80km", "120km", ">120km"))


ibd_mle_long_mtdt_dist %>%
  dplyr::group_by(distance_cat) %>%
  dplyr::summarise(
    n = n(),
    meanIBD = mean(malecotf),
    sdIBD = sd(malecotf),
    seIBD = sdIBD/sqrt(n),
    U95CI = meanIBD + 1.96 * seIBD,
    L95CI = meanIBD - 1.96 * seIBD) %>%
  ggplot() +
  geom_pointrange(aes(x = distance_cat, y = meanIBD, ymin = L95CI, ymax = U95CI)) +
  scale_size(range = c(0, 1)) +
  labs(y = "Mean IBD", x = "GC Distance", title = "Isolation by Distance") +
  theme_classic() +
  theme(plot.title = element_text(family = "Helvetica", face = "bold", hjust = 0.5, size = 14),
        axis.title = element_text(family = "Helvetica", face = "bold", hjust = 0.5, size = 12))

```
_**Conceptual Question:** How would you describe this relationship? Does it make sense?_
<br>
<br>

### Network Analysis
We can also use networks to determine the connectivity of our paired samples. Networks helps us visualize connections that we may not expect and are a useful tool for exploratory data analysis. Additionally, we can use [community detection algorithms](https://towardsdatascience.com/community-detection-algorithms-9bd8951e7dae) to explore which samples may "cluster" together based on relatedness. One way to conceptualize community detection algorithms is to consider that networks measure "popularity" and that samples that are "cliques" should cluster together. Alternatively, a sample may be "friends" with everyone and becomes very central or important to the network. These distinctions may be helpful to determine which demes are particularly connected and may be contributing to sink-source dynamics (see [Wesolowksi _et al._ 2018](https://pubmed.ncbi.nlm.nih.gov/30333020/) for further information on sink-source dynamics).
<br>
Read this STDHA [blog](http://sthda.com/english/articles/33-social-network-analysis/136-network-analysis-and-manipulation-using-r) networks and on community detection algorithms and use the R packages: [tidygraph](https://tidygraph.data-imaginist.com/index.html) and [ggraph](https://ggraph.data-imaginist.com/) to try to generate the figure below. 

```{r}
adj_graph <- ibd_mle_long %>%
  tidygraph::as_tbl_graph(., directed = F)

ibd_mle_long %>%
  tidygraph::as_tbl_graph(., directed = F) %>%
  dplyr::mutate(community = as.factor(tidygraph::group_louvain(weights = malecotf))) %>%
  tidygraph::activate("edges") %>%
  ggraph::ggraph(layout = 'kk') +
  ggraph::geom_edge_link(aes(width = malecotf,
                             color = malecotf)) +
  ggraph::geom_node_point(aes(color = community),
                          size = 3) +
  ggraph::scale_edge_width_continuous(range = c(0, 1), guide = "none") +
  ggraph::geom_node_text(aes(label = name), repel = T) +
  ggraph::scale_edge_color_viridis("IBD", values = c(0,1), option = "plasma") +
  scale_color_brewer(palette = "Set1") +
  ggraph::theme_graph() +
  theme(legend.position = "bottom")

```
_**Conceptual Question:** What do you notice about the above network? Are there any isolated cliques? Are there any very "popular" samples?_
<br>
<br>

## High Related Pairs
Here, we will subset to highly related pairs, defined as pairs that are at least meiotic siblings (_i.e._ share half of their genome). We will then map these between deme connections to determine if there is evidence of genetic sharing between demes. You can find the map at the following location: `data/sim_map_sf.RDS`. Use the `sf` package to make the plot below.

```{r}
# read in map base
simmap <- readRDS("data/sim_map_sf.RDS")
mtdtclst <- mtdt %>%
  dplyr::select(c("deme", "longnum", "latnum")) %>%
  dplyr::filter(!duplicated(.))

# perform subset
highpairs <- ibd_mle_long_mtdt %>%
  dplyr::filter(malecotf >= 0.5)
# find within
withinpairs <- highpairs %>%
  dplyr::mutate(win = deme_p1 == deme_p2)
# find btwn up
highbtwnpairs <- highpairs %>%
  dplyr::filter(deme_p1 != deme_p2)

# make plot
ggplot() +
  geom_sf(data = simmap) +
  geom_point(data = mtdtclst, aes(x = longnum, y = latnum),
             show.legend = F) +
  geom_point(data = withinpairs, aes(x = longnum_p1, y = latnum_p1),
             show.legend = F,
             color = "#0C73B2", shape = 15, size = 2) +
  geom_curve(data = highbtwnpairs,
             alpha = 0.5, size = 1.1,
             aes(x = longnum_p1, y = latnum_p1,
                 xend = longnum_p2, yend = latnum_p2,
                 color = malecotf), show.legend = F) +
  scale_color_viridis_c("Pairwise IBD", option="plasma", direction = 1, values = c(0,1)) +
  labs(caption = "Locations that contain highly related pairs within \n the deme are colored as blue squares; \n between deme connections are shown are curved lines") +
  theme_minimal() +
  theme(panel.grid = element_blank(),
        axis.title = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank())

```
_**Conceptual Question:** What can highly related pairs tell you? How do they relate to transmission events? Can you use them to estimate genetic corridors or evidence of gene flow? Do you think there is active transmission between the mainland and island (see original study hypothesis)?_
<br>
<br>


# Addendum {-}
You have reached the end of the practical. This section contains advanced material and additional resources for interested participants. If time permits, you can explore the advanced material challenge, the challenge questions, and/or the further readings. 

### Coding Challenges 
In this section, you will have the opportunity to explore and practice the skills above. 
<br>
Imagine that there are two populations: _A_ and _B_ with similar levels of falciparum incidence. However, there are only enough public health funds to intervene on one population. You have been asked by your National Malaria Control Programme (NMCP) to determine which population to intervene on. You first conduct a "travel survey" and determine that there are a high number of people that travel from _A_ to _B_. As a result, you hypothesis that _A_ is a "source" for _B_. Using the _VCF_ below, create a series of figure that you would present to your NMCP to encourage them to interview on population _A_ instead of _B_. Make sure to calculate IBD with multiple approaches to confirm your results. 

```{r}
# participants DO NOT need to include the quiet bit
ssvcf <- quiet(vcfR::read.vcfR("data/simulated_sink_source_ibd.vcf.gz"))
```



### Conceptual Challenges 
#### IBS & Polyclonality
Recently, [Tessema & Wesolowski et al. 2021](https://elifesciences.org/articles/43510) defined IBS for polyclonal samples as the proportion of sites that are identical divided by the potential alleles in all strains. Specifically, this can be expressed as for a pair of samples, $X$ and $Y$, the total number of shared alleles $S_{i}$ across the two samples divided by all alleles at that locus for sample $X$, $X_{i}$ and all alleles at that locus for sample $Y$, $Y_{i}$. This can be summed across all loci to produce an overall estimate of IBS.

$$IBS=  \frac{1}{n} \sum_{i=1}^{n} \frac{S_{i}} {X_{i}Y_{i}} $$

<br>
<br>
_**Challenge Question:** Can you think of a different approach to calculating IBS accounting for IBS that accounts for within-sample IBD? How woud you begin to account for this? Please share your answer with an instructor!_
<br>
<br>

#### IBD & Polyclonality
As was described in the case of `hmmIBD`, polyclonality greatly complicates IBD estimates and is an active area of research. Recent solutions include considering the malaria genome as diploid, which allows for heterozygous alleles: [`isoRelate`](https://github.com/bahlolab/isoRelate) or phasing polyclonal infections and estimating IBD from the resultant haplotypes: [deploidIBD](https://github.com/DEploid-dev/DEploid). This is an active area of research and remains a challenge within the malaria genomic epidemiology field.   

<br>
<br>
_**Challenge Question:** How would you approach calculating IBD in a high-transmission region with numerous likely polyclonal infections? What advantages are there to phasing data? Please share your answer with an instructor!_
<br>
<br>
_**Challenge Question:** How would would the IBD estimates above change if you used [`isoRelate`](https://github.com/bahlolab/isoRelate). Try to use the program to determine if your hypotheses are correct._
<br>
<br>

### Further Reading 
#### HMMs

Hidden Markov models (HMMs) are a common statistical approach in population genetics, and for detecting IBD. For further reading, see [Rabiner 1989](https://web.mit.edu/6.435/www/Rabiner89.pdf).  
<br>
<br>

#### Coalescent Theory

Coalescent theory is one of the central pillars of population genetics and provides a framework for how loci (genes, individuals, etc.) have been derived from a common ancestor backwards in time, classically using the assumptions of the Wright-Fisher model. One of the main assumptions of the coalescence, is that loci are independent and that no recombination is occurring between loci. To relax this assumption, we must consider the coalescence with recombination. In this framework, a single coalescent tree is no longer representative of the genome (*NB*: genomes are now combination of genes on intervals [0, L) ; [L, L\_{+1}], see [Griffiths & Marjoram 1996](http://lamastex.org/recomb/ima.pdf) for further details). As a result, each loci in the gene interval has a marginal tree due recombination resulting in different genealogical histories of loci. The collection of these trees with respect to recombination breakpoints among loci in the gene interval is termed the Ancestral Recombination Graph (ARG). Relatedness is considered as the time to most recent common ancestor (TMRCA) for a given loci and gives a more refined estimate of relatedness versus the binary distinction of whether or not a specific segment of the genome is IBD (*as discussed in our lecture*).

<p align="center">

![ARG for Three Samples with Two Discrete Loci](https://raw.githubusercontent.com/mrc-ide/AMMS2022/master/IBD/R_ignore/images/arg.png){width="500px"}

<br>

The following are an excellent launching point:   
[Wakeley: Coalescent Theory: An Introduction](https://www.amazon.com/Coalescent-Theory-Introduction-John-Wakeley/dp/0974707759)\
[Li & Stephens: 2003 PSMC](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1462870/)\
[Li & Durbin: 2011 PSMC](https://pubmed.ncbi.nlm.nih.gov/21753753/)
