---
title: "Calculating IBS & IBD"
author: "Nick Brazeau, Sophie Berube, Izzy Routledge, & Abebe Fola"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  html_document:
    theme: readable
    highlight: tango
    code_folding: show
    toc: yes
    toc_float:
      collapsed: no
      smooth_scroll: no
    toc_depth: 2
    number_sections: yes
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = T, warning = F, message = F,
                      fig.align = 'center', fig.keep = 'all')
```

# Dependencies for Practical {.unnumbered}

Please copy and paste the below code chunk in it's entirety to your console to download R package libraries needed for this practical. If you are having trouble installing any of the R packages, please ask an instructor for a pre-loaded flash drive.

```{r, class.source = "fold-show"}
deps <- c("tidyverse", "vcfR", "MIPanalyzer", "hmmibdr", "sf", "tidygraph", "ggraph")
deps <- !sapply(deps, function(x){x %in% installed.packages()[,1]} )
if(any(deps)) {
  if(deps["hmmibdr"]) {
    if (!"remotes" %in% installed.packages()[,1]){
      install.packages("remotes")
    }
    remotes::install_github("OJWatson/hmmibdr")
    deps <- deps[names(deps) != "hmmibdr"]
  } else if(deps["MIPanalyzer"]) {
    if (!"remotes" %in% installed.packages()[,1]){
      install.packages("remotes")
    }
    remotes::install_github("mrc-ide/MIPanalyzer")
    deps <- deps[names(deps) != "MIPanalyzer"]
  } else {
    install.packages(names(deps)[deps])
  }
}

```

Please now load all of those libraries into this session using the code chunk below. Please copy and paste it in its entirety.

```{r, class.source = "fold-show"}
library(tidyverse)
library(vcfR)
library(hmmibdr)
library(sf)
library(tidygraph)
library(ggraph)
library(cowplot)
```

Finally, please source (*i.e.* load) the file called `utils.r` that is stored under the `IBD/R` directory. If you are using the `IBD.Rproj` environment, you can just run `source("R/utils.R")` as below. Or if you are running from a different environment or working directory (`getwd()`), use the `file.choose` function to help locate the file.

```{r, class.source = "fold-show"}
source("R/utils.R")
```

# Introduction {.unnumbered}
## Useful Definitions {.unnumbered}
_**Definition:** An allele is the state of a particular genetic locus or sequence that is inherited between parents and offspring._ <br>
_**Definition:** A locus is a fixed position on a chromosome where a particular genetic marker is located._ <br>
_**Definition:** Sequencing data consists of sequences of DNA obtained from a DNA sequencing reaction_ <br>
_**Definition:** Complexity of infection, or multiplicity of infection, is a measure of the number of different malaria parasite clones in an individual sample._ <br>
_**Definition:** A monoclonal malaria infection contains one parasite strain, or "genome" (complexity of infection [COI] = 1), while a polyclonal infection contains more than one parasite strain (COI > 1)._ <br>
_**Definition:** A deme is a local population that has individuals that interbreed and share genetic material._ <br>
<br>
<br>

## Relatedness Overview {.unnumbered}

During prior sessions, you have explored how to estimate relationships based on levels of population diversity, structure, and connectivity. In this practical, we will focus on between-parasite, or pairwise, measures of genetic relatedness. These are more "individual" focused measures of relatedness versus population, or deme, focused measures of relatedness.
<br>
There are two mains ways to estimate relatedness among individuals: identity by descent (IBD) or Time to Most Recent Common Ancestor (TMRCA) (see [Speed & Balding 2015](https://pubmed.ncbi.nlm.nih.gov/25404112/) for further discussion). We will be focusing on IBD, which leverages recombination to detect recent common inheritance of genetic material, or genetic relatedness.
<br>
<br>
<br>

## IBS/IBD Overview {.unnumbered}

As described in the lecture, we can consider pairwise relatedness by determining if the genetic sequence at a give position in the genome, a loci, between two parasites is identical (e.g. the same allele). We can either simply measure the number of sites with identical alleles between two individuals, termed identity by state (IBS), or, we can use statistical models to determine if identical alleles and "blocks" of the genome were likely to be inherited from a common ancestor, termed identity by descent (IBD). It is important to note the differences between IBS and IBD: IBS refers to the "state" or realization of the allele at a loci and can be the result of numerous factors other than ancestry (e.g. selection, drift, structure, chance). In contrast, IBD solely refers to inherited genetic material, which follow specific patterns relevant to public health that we will explore below. The differences between IBS and IBD are visualized in the schematic below, where sites may be IBS but not IBD, whilst all sites that are IBD are IBS.

<p align="center">
![](https://raw.githubusercontent.com/mrc-ide/AMMS2022/master/IBD/R_ignore/images/ibd_vs_ibs.png){width="300px"}
</p>


# Overview of Data {.unnumbered}
This data was simulated using a simple malaria model that takes into account spatial relationships, complexity of infection (COI), and population size under a Wright-Fisher model: [PolySimIBD](https://github.com/nickbrazeau/polySimIBD) - originally published in [Verity/Aydemir/Brazeau et al. 2020](https://pubmed.ncbi.nlm.nih.gov/32355199/). _Note_, the simulated data has a single chromosome  that is only 1,000 base pairs long (much smaller than malaria chromosomes) and as a result, has a much smaller recombination rate (relevant for `hmmIBD` input parameters.)
<br>
For this practical, we have simulated five populations, or demes: A-E. The demes were simulated to have the same number of people, or hosts; however, we have randomly selected five individuals from each deme to undergo molecular surveillance and be "sequenced" (_i.e._ in real life, you may select five participants from a village to donate whole-blood vs collecting blood from every individual in the village). The demes have varying intensity of transmission, or incidence, as indicated by the spectrum of yellow-red in the schematic legend. In addition, we expect for mosquitoes to migrate between the demes with respect to how far the demes are from each other (_i.e._ isolation by distance). Finally, we _hypothesize_ that the ocean between demes A-D and E is a barrier to any transmission from the "mainland" to the "island" (_i.e._ we expect mainland parasites to be distinct from island parasites). In summary, the data consists of:    

- Five demes (4 mainland, 1 island)   
- Locations are known for each deme    
- Five random samples from each deme
- Incidence as estimated by mean COI per deme\*

_\*As discussed yesterday, COI is a poor measure of incidence in the real world. For our model, it is quite correlated (in expectation) and will be used as a proxy here._
<br>

<p align="center">
![](https://raw.githubusercontent.com/mrc-ide/AMMS2022/master/IBD/R_ignore/images/sim_deme_schematic.png){width="500px"}
</p>

# Practical Goals {.unnumbered}

By the end of this practical, you should able to perform the below tasks and understand the following concepts:     
+ Calculate IBS    
+ Calculate IBD    
+ IBS is straightforward to calculate but can produce biased estimates of relatedness (*i.e.* does not necessarily reflect ancestry and is affected by population level allele frequencies)      
+ IBD captures recent relatedness, useful for determining transmission events, transmission intensity, importation, and corridors of gene flow       
- Therefore, IBS/IBD can measure connectivity on spatial-temporal scales relevant to malaria control and elimination efforts          
+ IBD should decay with distance (isolation by distance) and time; when it does not, interesting things may be happening    

---------------------------------------------------------------------

# Importing Data

Here, we will use the `vcfR` [package](https://knausb.github.io/vcfR_documentation/) to read in our variant call file (VCF) that contains fifty biallelic SNPs for our twenty-five individuals across our five populations (A, B, C, D, E; *individuals named* A1-5, B1-5, ...).

Using the skills that you acquired yesterday, read in the VCF from our data folder that you downloaded from Github: `data/simulated_ibd.vcf.gz`. If you are having trouble locating the file on your computer, please type `file.choose` into your console for an interactive option to locate the file. Name the object (the vcf file you are reading in) "vcf" for simplicity.

```{r}
# participants DO NOT need to include the quiet bit
vcf <- quiet(vcfR::read.vcfR("data/simulated_ibd.vcf.gz"))
```

## Initial QC
As is always good practice, we can check our VCF for missing data and confirm it has the number of SNPs and samples that we expect. Explore the details and inner-workings of our new VCF to get a sense if it is trustworthy (_i.e._ does the data look reasonable? Is there anything strange in the INFO column?). 


_**Coding Question 1:** Use the `extract.gt` function from the vcfR package to pull out the allele depth for the first record (referent allele) for your new VCF. Now plot that allele depth as an initial data exploration using the `heatmap.bp` function from the `vcfR` package to generate the figure below._

`r begin_button(1)`
```{r}
ad <- vcfR::extract.gt(vcf, element = "AD", as.numeric = T)
vcfR::heatmap.bp(ad)
```
`r end_button()`
`r hrule()`
<br> 

_**Conceptual Question 1:** Is above plot consistent w/ a high quality VCF? What are some questionable features?_

`r begin_button(101)`
_**Conceptual Answer 1:**_ While it does look high quality, there are several features that would make you question if it was real data:    
- All of the REF/ALT basepair allele calls are "N" missing  
- All of the loci allele depths are 100  
- The QUALTIY column is all the same  
<br>
<br>
This data was simulated, and thus, lacks many of the "real world" appearances of a VCF generated from real sequencing data. It is always valuable to manually look at the VCF to determine if it's valid before starting analyses!
<br>

`r end_button()`
`r hrule()`
<br> 

## Exploring Hets
Here, we will explore the number of heterzygous genotype calls we have per sample in our VCF. Remember, heterzygous genotype calls give us a crude approximation of COI. 
<br>

**Coding Question 2:** Again, use the `extract.gt` function from the vcfR package and pull out the genotype calls (`element = "GT"`) for all samples. Then wrangle the data into "long" format using `pivot` longer. Once you have "tidy long" data, calculate the mean heterozygosity per sample using the `summarise` function and plot the data in a scatterplot, as below.
```{r, echo = F}
# extract and tidy
gt <- vcfR::extract.gt(vcf, element = "GT")
gt <- dplyr::bind_cols("chrom" = vcfR::getCHROM(vcf), "pos" = vcfR::getPOS(vcf), gt)
gt %>%
  tibble::as_tibble() %>%
  tidyr::pivot_longer(., cols = !c("chrom", "pos")) %>%
  dplyr::mutate(ishet = dplyr::case_when(value == "0/0" ~ F,
                                         value == "0/1" ~ T,
                                         value == "1/1" ~ F)) %>%
  dplyr::group_by(name) %>%
  dplyr::summarise(
    propHet = mean(ishet)) %>%
  ggplot() +
  geom_point(aes(x = name, y = propHet)) +
  ylab("Proportion of Sample that is Het") +
  xlab("") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.75, hjust = 0.5))
```

`r begin_button(2)`
```{r}
# extract and tidy
gt <- vcfR::extract.gt(vcf, element = "GT")
gt <- dplyr::bind_cols("chrom" = vcfR::getCHROM(vcf), "pos" = vcfR::getPOS(vcf), gt)
gt %>%
  tibble::as_tibble() %>%
  tidyr::pivot_longer(., cols = !c("chrom", "pos")) %>%
  dplyr::mutate(ishet = dplyr::case_when(value == "0/0" ~ F,
                                         value == "0/1" ~ T,
                                         value == "1/1" ~ F)) %>%
  dplyr::group_by(name) %>%
  dplyr::summarise(
    propHet = mean(ishet)) %>%
  ggplot() +
  geom_point(aes(x = name, y = propHet)) +
  ylab("Proportion of Sample that is Het") +
  xlab("") +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 45, vjust = 0.75, hjust = 0.5))
```
`r end_button()`
`r hrule()`
<br>


_**Conceptual Question 2:** Do you recognize any pattern in heterozygote calls with respect to demes? How does this relate to the polyclonality lesson yesterday?_
`r begin_button(102)`
_**Conceptual Answer 2:**_ Demes with higher transmission intensity have more heterozygote calls.
`r end_button()`
`r hrule()`
<br>

# Intuition
Recombination produces a powerful signal for detecting genetic relatedness between individuals. In malaria, recombination occurs in the mosquito midgut. As a reminder, the schematic below shows a single mosquito that has bitten two different individuals infected with a single strain of the malaria parasite, resulting in a superinfection. The two strains (red vs purple) then undergo recombination in the mosquito midgut and produce progeny that are siblings and expected to share half of their genomes on average (*they are seperated by 1 generaton*). The pedigree on the right highlights two of the parasite siblings and has a grey bar indicating how much of their genome was inherited from the same parent in the same genomic location. 
<br>
<p align="center">
![](https://raw.githubusercontent.com/mrc-ide/AMMS2022/master/IBD/R_ignore/images/ibdsiblings.png){width="500px"}
</p>
<br>



## Visualizing Recombination
As a result, one way to conceptualize the genome is as blocks, or segments, that are joined together, where each block has its own unique ancestral history. Thus, recombination can be thought of as the "stick breaking" process that breaks the genome segments/IBD blocks up: as time increases, or the number of generations increases, the genomic blocks that are shared between individuals become smaller. For example, you can imagine that you have two sticks that are identical (_i.e._ twins, or clonal infections). In each new generation, you have to randomly break your stick at some point along its length. You then take your pieces of stick and flip a coin to determine if it will remain the same ("original") or inherit genetic material ("new"). Use the `view_recombo` (loaded from `R/utils.R`) function and explore the relationship between the number of generations, or time, and the length of recombination blocks that are IBD between the clones. The figure below shows the results for 20 generations. 
<br>
<br> 
```{r, echo=F}
view_recombo(generations_apart = 20) +
  labs(title = "Breakdown of Clonal Material \n over 20 Generations",
       caption = "Note, new material is not necessarily IBD")

```
<br>
<br>
**For example, you could run the function with the following generational times**
```{r, eval=F}
view_recombo(generations_apart = 0)
view_recombo(generations_apart = 1)
view_recombo(generations_apart = 2)
view_recombo(generations_apart = 3)
view_recombo(generations_apart = 5)
view_recombo(generations_apart = 10)
view_recombo(generations_apart = 20)
```
<br>
<br>
_**Conceptual Question 3:** How does the amount of "clonal" genetic material change, or amount of the genome that is identical, change between the paired samples as we increase the number of generations that separates them?_
`r begin_button(103)`
_**Conceptual Answer 3:**_ Decreases. This is an important point, as "blocks" of DNA are our unit of analysis in IBD.  
`r end_button()`
`r hrule()`
<br>
<br>

# Calculations

### Internal Data Manipulation

Here, we are going to convert our _vcf_ object that we read in with the `vcfR` package to a _mip_ object in order to later use the [`MIPAnalyzer` Package](https://github.com/mrc-ide/MIPanalyzer/tree/master/R) and the maximum likelihood estimator of IBD from [Verity et al. 2020](https://pubmed.ncbi.nlm.nih.gov/32355199/). This is purely for convenience and is not changing the underlying data in the vcf.Please copy and paste the code below into your console.

```{r}
mipvcf <- MIPanalyzer::vcf2mipanalyzer_biallelic(vcfR = vcf)
```

## Identity by State
Identity by state (IBS) is the proportion of identical loci divided by all measured loci in the genome between two parasites: $\mbox{parasite}_a$ and $\mbox{parasite}_b$, such that: $$IBS= \frac{\mbox{Shared loci}_{ab}}{\mbox{Number of loci}}$$
<br>
Here, we will perform IBS calculations using our VCF as input. 
<br>

_**Coding Question 3:**_ Pick two samples from your VCF and write your own function to calculate IBS between the pair. I recommend starting with the `vcfR` object (vs. newly created `mipanalyzer_biallelic` object) and using the `extract.gt` function from the vcfR package to pull out the genotype calls (`element = "GT"`) as above. Then subset the data to two samples and compare loci.

`r begin_button(3)`
```{r, eval=F}
# pick two samples
simpleIBS <- function(vcfRobj, smpl1name, smpl2name) {
  # extract GT information from vcf
  gt <- vcfR::extract.gt(vcfRobj, element = "GT")
  # subset to our samples, these are now vectors
  smpl1 <- gt[,smpl1name]
  smpl2 <- gt[,smpl2name]
  # evaluate if each element in vector is the same or different = Boolean result
  # take mean to get a proportion (binomial mean)
  ibsprop <- mean(smpl1 == smpl2)
  return(ibsprop)
}

simpleIBS(vcfRobj = vcf, smpl1name = "A1", smpl2name = "D1")

```
`r end_button()`
`r hrule()`
<br> 

### Run Package IBS
Next, we will use the IBS calculator from the `MIPAnalyzer` R package to calculate pairwise IBS for all combinations of samples in our simulated data. Please copy and paste the code below into your console for ease of running the algorithm.  

```{r}
# get IBS
ibs <- MIPanalyzer::get_IBS_distance(x = mipvcf,
                                     ignore_het = FALSE,
                                     report_progress = FALSE)
```

#### Tidy Results
The function returns the data in a "wide" format, or a [distance matrix](https://en.wikipedia.org/wiki/Distance_matrix). While this a perfectly acceptable format, it is not considered "tidy". 

_**Coding Question 4:**_: Wrangle the data into "long" format using `broom::tidy` function. Rename the columns for the long data to `c("p1", "p2", "ibsdist")`. Note, make sure to preserve the sample names from `colnames(vcf@gt)[2:ncol(vcf@gt)]` prior to tidying!

`r begin_button(4)`
```{r}
# tidy result
colnames(ibs) <- rownames(ibs) <- colnames(vcf@gt)[2:ncol(vcf@gt)]

ibs_long <- broom::tidy(as.dist(ibs)) %>%  
  magrittr::set_colnames(c("p1", "p2", "ibsdist"))
```
`r end_button()`
`r hrule()`
<br> 

It is always good practice to explore our results. Let's make a boxplot to explore the distribution of our calculated IBS results. 
<br>
_**Coding Question 5:**_: Finished the code below to create a boxplot with IBS values on the y-axis. 
```
ibs_long %>%
  ggplot() +
  geom_boxplot(***) +
  ylab("IBS Values") +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank())
```

`r begin_button(5)`
```{r}
# boxplot result
ibs_long %>%
  ggplot() +
  geom_boxplot(aes(y = ibsdist),
               outlier.colour = "red", outlier.shape=8,
               outlier.size=4) +
  ylab("IBS Values") +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank())
```
`r end_button()`
`r hrule()`
<br> 

_**Conceptual Question 4:** Describe the distribution. Is this what you expected?_
`r begin_button(104)`
_**Conceptual Answer 4:**_ The distribution is approximately normal with a mean around 0.72. There is one outlier value with a value of 0.96. This suggests that there are not many segregating sites in this population. 
`r end_button()`
`r hrule()`
<br> 
<br>

## Identity by Descent
Identity by Descent (IBD) is more complicated to calculate than IBS and requires statistical modeling in order to account for recombination and population allele frequencies. The most common statistical model used is called a Hidden Markov Model (see the *Further Reading* section for recommended sources). Remember, a site can be IBS but not necessarily IBD as described in the [IBS/IBD Overview] section. 
<br>
Here, we will use two different algorithms to calculate IBD: (1) an MLE inbreeding estimator; (2) a hidden Markov model.
<br>

#### MLE IBD
This first algorithm uses a maximum likelihood estimator of IBD (see [Verity et al. 2020](https://pubmed.ncbi.nlm.nih.gov/33057671/) for a mathematical description). The model assumes that loci are independent, which allows for IBD to be essentially calculated as the amount of inbreeding, or deviation from the expected allele frequencies, between allele frequencies per site. The model is a variation of the Generalized [Hardy-Weinberg equation](https://en.wikipedia.org/wiki/Hardy%E2%80%93Weinberg_principle) for nonrandom mating (see [Gillespie, Population Genetics: A Concise Guide](https://public.wsu.edu/~gomulki/mathgen/materials/gillespie_book.pdf) 1st edition, pg 86, for further reading). 
<br>
As above, we will use `MIPAnalyzer` R package to calculate pairwise IBD for all combinations of samples in our simulated data. For convenience, copy and paste the code below into your console to acquire these results. 

```{r}
#......................
# MLE IBD
#......................
ibd <- MIPanalyzer::inbreeding_mle(x = mipvcf,
                                   f = seq(0.01, 0.99, 0.01),
                                   ignore_het = FALSE,
                                   report_progress = FALSE)
```

<br>
_**Coding Question 6:**_: Let's now tidy/convert our data to "long" format again using the `broom::tidy` function. Make sure to set your diagonal to 1 (self comparisons), preserve the sample names, and name your columns `c("p1", "p2", "malecotf")`. 

`r begin_button(6)`
```{r}
# tidy result
diag(ibd$mle) <- 1
colnames(ibd$mle) <- rownames(ibd$mle) <- colnames(vcf@gt)[2:ncol(vcf@gt)]

ibd_mle_long <- broom::tidy(as.dist(t(ibd$mle))) %>%  # note, mipanalyzer returns upper triangle
  magrittr::set_colnames(c("p1", "p2", "malecotf"))
```
`r end_button()`
`r hrule()`
<br> 

After generating our new results, we always explore them! <br>
_**Coding Question 7**_: Using the `geom_boxplot` code from above, create a boxplot with IBD values on the y-axis.
`r begin_button(7)`
```{r}
# boxplot result
ibd_mle_long %>%
  ggplot() +
  geom_boxplot(aes(y = malecotf),
               outlier.colour = "red", outlier.shape=8,
               outlier.size=4) +
  ylab("IBD MLE Values") +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank())

```
`r end_button()`
`r hrule()`
<br> 


_**Conceptual Question 5:** Describe the MLE distribution. Is this what you expected?_
`r begin_button(105)`
_**Conceptual Answer 5:**_ The distribution is centered over approximatley 0-0.1, suggesting that most pairs have very little IBD. However, there are a few pairs with high levels of IBD. 
`r end_button()`
`r hrule()`
<br> 
<br>

#### IBD from HMM 
Next, we will use a hidden Markov model (HMM) from the R-package `hmmIBDR`, which is a wrapper for the original `hmmIBD` algorithm (for a full mathematical description of `hmmIBD` see [Schaffner & Taylor 2018](https://pubmed.ncbi.nlm.nih.gov/29764422/)) to calculate IBD estimates. As described in the lecture, HMMs can be thought of a statistical model that uses "observations" to infer the "hidden" state of some process, where the process is known or can be described. In our case, our observations are genotype calls between individuals (identical sites versus discordant sites) and our hidden state is whether or not that site is a region of common inheritance between individuals (IBD) or not. The underlying process is recombination, which we know breaks up genomic blocks, and can be described based on the known recombination rate in malaria. This [site](https://towardsdatascience.com/markov-and-hidden-markov-model-3eec42298d75) provides a useful non-genomic example: imagine you call a friend every day that lives far away, and that friend has two "state's" of mind: grumpy or happy. You know that your friend's mood is dependent on the weather, but we don't know the weather in this far away place (it is "hidden" from us). However, we can infer what the weather was that day based on whether our friend was happy or grumpy when we spoke to them. Moreover, if we recorded our friend's mood for a week, we could use a model to infer the weather pattern over that entire week based on the observed sequence of our friend's "state" of mind as shown in the schematic below. For example, if our friend was G,G,G,H,H,H,H we may suspect that it rained for the first three days of the week but then there was a state change and it was sunny the last four days of the week.  

<p align="center">
![](https://raw.githubusercontent.com/mrc-ide/AMMS2022/master/IBD/R_ignore/images/hmm_example.png){width="500px"}
</p>

<br>
<br>

##### Formatting for `hmmIBD`
Prior to running `hmmIBD` [program](https://github.com/glipsnort/hmmIBD), we are going to have to do some data munging.
<br>
_**Coding Question 8, part 1**_: Make a within-sample alternative allele frequency (WSAF) matrix. First, start by extracting the alternative allele, or the number of alternative reads, at a particular locus per sample using the `vcfR::extract.gt(vcf, element = "AD")` function: (the numerator). Next, calculate the total allele depth per locus, per sample using the `vcfR::extract.gt(vcf, element = "DP")` function: (the denominator). Now, find the WSAF by dividing the numerator by the denominator and name this new matrix `wsaf`. 

`r begin_button(8)`
```{r}
#............................................................
# hmmIBD setup
#...........................................................
#......................
# part 1
#......................
# File of genotype data
ad <- vcfR::extract.gt(vcf, element = "AD")
dp <- vcfR::extract.gt(vcf, element = "DP", as.numeric = T)
altad <- vcfR::masplit(ad, record = 2, sort = F)
wsaf <- altad/dp
colnames(wsaf) <- colnames(vcf@gt)[2:ncol(vcf@gt)]
```
`r end_button()`
`r hrule()`
<br> 

_**Coding Question 9, part 2**_: In order to convert this dataframe into a "`hmmIBD` compliant dataframe, first, add the chromosome and position to your wsaf matrix (as the first and second columns respectively) and name it `gtmat`. Then tidy your "wide" matrix to "long" format excluding the chromosome and position (*i.e.* we want a dataframe with chromosome, position, sample, wsaf as our columns) with the function: `tidyr::pivot_longer(., cols = !c("chrom", "pos"))`. We are now going to coerce are WSAF calculations into homozygous genotype calls using rounding: `gthmm = round(value, 0)`. In addition, make sure to drop the `value` column (now redundant) and for `hmmIBD` liftover the chromosome names to integers: (`chrom = 1)`. In a turn of events, we will now make our data "wide" from long and write out this new table to your local drive for `hmmIBD` using the functions: `tidyr::pivot_wider(data = ., names_from = "name", values_from = "gthmm")` and `readr::write_tsv(x = gtmat, file = "data/gt_matrix_for_hmmIBD.txt", col_names = T)`, respectively. 

`r begin_button(9)`
```{r}
#......................
# part 2
#......................
gtmat <- dplyr::bind_cols("chrom" = vcfR::getCHROM(vcf), "pos" = vcfR::getPOS(vcf), wsaf)
gtmat <- gtmat %>%
  tidyr::pivot_longer(., cols = !c("chrom", "pos")) %>%
  dplyr::mutate(chrom = 1,
                gthmm = round(value, 0)) %>%
  dplyr::select(-c("value")) %>%
  tidyr::pivot_wider(data = ., names_from = "name", values_from = "gthmm")
readr::write_tsv(x = gtmat, file = "data/gt_matrix_for_hmmIBD.txt",
                 col_names = T)
```
`r end_button()`
`r hrule()`
<br> 

_**Coding Question 10, part 3**_: Finally, using your `wsaf` matrix, calculate the population level allele frequencies for each locus using the following function: `altafvec <- rowMeans(wsaf, na.rm = T)`. Remember, this is the alternative allele frequency, and because we are dealing with biallelic sites, we can calculate the referent allele frequency as 1-alt and place this all in a dataframe. The dataframe needs a chromosome column (as a numeric/integer [`chrom = 1`]), a column for locus' basepair position, a referent allele frequency column, and an alternative allele frequency column. Write this table out to your local drive with the following path: `data/af_matrix_for_hmmIBD.txt`.
<br>
`r begin_button(10)`
```{r}
#......................
# part 3 
#......................
# File of allele frequencies for the sample population. Format: tab-delimited, no header, one variant per row. Line format: <chromosome (int)> <position (bp, int)> <allele 1 freq> <all 2 freq> [<all 3 freq>] ... The genotype and frequency files must contain exactly the same variants, in the same order. If no file is supplied, allele frequencies are calculated from the input data file.
altafvec <- rowMeans(wsaf, na.rm = T)
afmat <- dplyr::bind_cols("chrom" = vcfR::getCHROM(vcf),
                          "pos" = vcfR::getPOS(vcf),
                          1-altafvec, altafvec) %>%
  dplyr::mutate(chrom = 1)
readr::write_tsv(afmat, file = "data/af_matrix_for_hmmIBD.txt", col_names = F)
```
`r end_button()`
`r hrule()`
<br> 

Explore the [hmmIBD documentation](https://github.com/glipsnort/hmmIBD) for a justification of this munging that we did above and further clarfication of the caveat below. 

_**Caveat**: The `hmmIBD` algorithm assumes that all samples are monoclonal. As a result, it does not accept heterozygote calls natively. As a user, we have two options: (1) to set those heterozygote calls to missing (a conservative approach), or (2) make a strong assumption about what a heterozygote call means (an aggressive approach). Here, I have forced the samples to be monoclonal by estimating their within-sample allele frequencies and rounding to the nearest variant._

<br>
<br>
<br>

##### Running hmmIBD 
Now we will run the `hmmIBD` program to calculate pairwise IBD. For convenience, copy and paste the code below into your console to acquire these results. 

```{r}
#......................
# hmmIBD run
#......................
# NB, participants do not need to use the "quiet" function 
tf <- tempfile(pattern = "output_simdat")
out <- quiet(hmmibdr::hmm_ibd(input_file = "data/gt_matrix_for_hmmIBD.txt",
                              allele_freqs =  "data/af_matrix_for_hmmIBD.txt",
                              rec_rate = 1e-2, # note the small recombo rate relative to what would be expected in malaria
                              output_file = tf))

# hmmIBD tidy
ibd_hmm_long <- tibble::tibble(
  p1 = out$fract$sample1,
  p2 = out$fract$sample2,
  hmm = out$fract$fract_sites_IBD)


```

Again, we always explore our results! <br>
_**Coding Question 11**_: Use your `geom_boxplot` code to create a boxplot with IBD HMM values on the y-axis.
`r begin_button(11)`
```{r}
# boxplot result
ibd_hmm_long %>%
  ggplot() +
  geom_boxplot(aes(y = hmm),
               outlier.colour = "red", outlier.shape=8,
               outlier.size=4) +
  ylab("IBD HMM Values") +
  theme_bw() +
  theme(axis.text.x = element_blank(),
        axis.ticks.x = element_blank())

```
`r end_button()`
`r hrule()`
<br> 

_**Conceptual Question 6:** Describe the HMM distribution. Is this what you expected?_
`r begin_button(106)`
_**Conceptual Answer 6:**_ The distribution is centered over approximatley 0-0.05, suggesting that most pairs have very little IBD. THis suggests lower levels of relatedness than demonstrated in the MLE distribution above. Again, there are a few pairs with high levels of IBD. 
`r end_button()`
`r hrule()`
<br> 
<br>

#### Contrast MLE vs HMM
As described above, the IBD calculations from the MLE model assume independent loci, while the HMM model leverages recombination to detect relatedness. However, `hmmIBD` requires monoclonal infections and we had to "coerce" our data to fit that assumption. Here, we will explore how the MLE IBD and the HMM IBD results differ. 

<br>
_**Coding Question 12**_: Use the `geom_point` ggplot layer to create a plot that contrast the two different calculations. You will need to join the data by sample using the following function: `left_join(ibd_mle_long, ibd_hmm_long, by = c("p1", "p2"))` by finishing the code chunk below. 

```
dplyr::left_join(***) %>%
  ggplot() +
  geom_point(***) +
  theme_bw() +
  labs(x = "IBD from HMM", y = "IBD from MLE")
```

`r begin_button(12)`
```{r}
dplyr::left_join(ibd_mle_long, ibd_hmm_long, by = c("p1", "p2")) %>%
  ggplot() +
  geom_point(aes(x = hmm, y = malecotf)) +
  theme_bw() +
  labs(x = "IBD from HMM", y = "IBD from MLE")


```
`r end_button()`
`r hrule()`
<br> 

_**Conceptual Question 7:** Why would these two results differ? Are there any differing assumptions made in the models?_
`r begin_button(107)`
_**Conceptual Answer 7:**_ Remember that `hmmIBD` assumes that samples are monoclonal. Therefore, heterozygote calls will break down IBD blocks rapidly under our simple "force" to monoclonal assumption.
`r end_button()`
`r hrule()`
<br> 
<br>

#### Contrast IBS vs HMM-IBD
Compare IBS and the `hmmIBD` results in a scatterplot.  
_**Coding Question 12**_: Using the `geom_point` ggplot layer, create a plot that contrast the IBS estimations and the MLE IBD estimations. Add a regression line to explore the correlation using the `geom_smooth(aes(x = malecotf, y = ibsdist), method = "lm")` layer. Note, you will need to join the data by sample using the following function: `left_join(ibs_long, ibd_mle_long, by = c("p1", "p2"))` prior to using ggplot.
`r begin_button(12)`
```{r}
dplyr::left_join(ibs_long, ibd_hmm_long, by = c("p1", "p2")) %>%
  ggplot() +
  geom_point(aes(x = hmm, y = ibsdist)) +
  geom_smooth(aes(x = hmm, y = ibsdist), method = "lm") +
  xlim(c(0,1)) + ylim(c(0,1)) +
  labs(x = "HMM-IBD Estimates", y = "IBS Distance") +
  theme_bw()

```
`r end_button()`
`r hrule()`
<br>

_**Conceptual Question 8:** How do the estimates of IBS and IBD differ. What is the smallest value for IBS versus IBD? Why may these be different?_
`r begin_button(108)`
_**Conceptual Answer 8:**_ IBS is affected by the population allele frequencies in a population and can overestimate relatedness when alleles are fixed in a population due to reasons other than inheritance (i.e. IBD = 0, IBS > 0.5, seen on the left-hand side of the plot). Fixation of alleles is particularly common in small populations due to genetic drift (as was the case in this simulation) or due to selection. As a result, although high values of IBS likely indicate high levels of relatedness, lower values of IBS are more difficult to interpret.
`r end_button()`
`r hrule()`
<br> 

### Summary/Check-In
At this point, you should have created three R result objects:       
```
ibs_long     
ibd_mle_long     
ibd_hmm_long     
```  
If you are having computational trouble or time is a limiting factor, please see the `results/` directory, where you will be able to read in the results.

<br>
<br>
<br>
<br>

# Applied IBD
In this section, we will focus on the utility of IBD for realistic applications related to control and elimination efforts. For this section, we will focus on the MLE-IBD estimates (versus HMM-IBD estimates).

## IBD Distribution
First, let's look at the distribution of our IBD estimates. In particular, we will focus in on the "tail" of the distribution (_i.e._ high values). Plotting the IBD distributions help to convey how interbred our population is, and if we expect there to be highly related pairs that are of importance for revealing corridors of gene flow (assessed later).
<br>
_**Coding Question 13**_: Use the `geom_histogram` ggplot layer to reate a plot that shows the distribution of MLE IBD estimations. We will add an inset plot to explore the tail of this distribution. Explore this [blog](https://meghan.rbind.io/blog/cowplot/) to learn how to make plots with insets using the `cowplot` package. 
`r begin_button(13)`
```{r}
mainplot <- ibd_mle_long %>%
  ggplot() +
  geom_histogram(aes(x=malecotf, y = (..count../sum(..count..))*100),
                 color = "#000000", fill = "#d9d9d9") +
  xlab("IBD") + ylab("frequency (%)") +
  theme_classic()

insetplot <- ibd_mle_long %>%
  ggplot() +
  geom_histogram(aes(x=malecotf, y = (..count../sum(..count..))*100),
                 color = "#000000", fill = "#d9d9d9") +
  xlab("IBD") + ylab("frequency (%)") +
  theme_classic() +
  coord_cartesian(xlim = c(0.5,1), ylim = c(0,0.8)) +
  theme_bw() +
  theme(panel.background = element_rect(fill = "transparent"),
        plot.background = element_rect(fill = "transparent"))
# cowplot
cowplot::ggdraw() +
  cowplot::draw_plot(mainplot, x = 0, y = 0, width = 1, height = 1, scale = 1) +
  cowplot::draw_plot(insetplot, x = 0.5, y= 0.3, width = 0.4, height = 0.4)

```
`r end_button()`
`r hrule()`
<br> 

_**Conceptual Question 9:** How would you describe this distribution? Would you expect this many unrelated samples? What about the proportion of highly related pairs in the tail of the distribution?_
<br>
<br>
`r begin_button(109)`
_**Conceptual Answer 9:**_ The distribution is similar to our boxplot above, demonstrating that there are a large number of unrelated to lowly-related pairs. This is to be expected in many populations, unless there are reasons for a large amount of inbreeding (see lecture: factors that affect relatedness). However, there is a "tail" with a few highly related pairs. This tail is of interest! 
`r end_button()`
`r hrule()`
<br> 
<br>

## Transmission Intensity
As we have seen from the recombination review at the beginning of the practical, as the number of recombination events increases, we expect for IBD due to decrease. As a result, in areas with higher transmission intensity, here modeled through differences in COI, we can expect for IBD to be less.

### Within-Deme IBD vs COI
By grouping samples together by their home demes, we can estimate the amount of inbreeding within a deme, or the within-deme IBD. Here, we will read in the `data/metadata.RDS` file and calculate the mean IBD by deme to get the within-deme IBD. We will then plot the within-deme IBD versus simulated mean COI.  
<br>  
<br>
_**Coding Question 13, part 1**_: Read in the metadata using the following code: `readRDS("data/metadata.RDS")`. Then combine our metadata to the `ibd_mle_long` dataframe using two different `left_join` calls. Note, you will need to make two different "metadata" dataframe with a column named "p1" (sample 1) and one wth a column named "p2" (sample 2). Rename the ".x" and ".y" extensions created by `left_join` to "_p1" and "_p2", respectively. 
After joining this data together, you should have a new dataframe with column names: `p1, p2, malectof, deme_p1, coimeans_p1, longnum_p1, latnum_p1, deme_p2, coimeans_pe2, longnum_p2, latnum_p2`. We are going to use this dataframe for the next few challenges, so please name it `ibd_mle_long_mtdt`.
<br>
`r begin_button(13)`
```{r}
#......................
# part 1
#......................
mtdt <- readRDS("data/metadata.RDS")
# data munging
mtdt_x <- mtdt %>%
  dplyr::rename(p1 = smpl)
mtdt_y <- mtdt %>%
  dplyr::rename(p2 = smpl)
ibd_mle_long_mtdt <- dplyr::left_join(ibd_mle_long, mtdt_x, by = "p1") %>%
  dplyr::left_join(., mtdt_y, by = "p2") %>%
  rename_with(., ~gsub(".x", "_p1", .x, fixed = T)) %>%
  rename_with(., ~gsub(".y", "_p2", .x, fixed = T))
```
`r end_button()`
`r hrule()`
<br> 

_**Conceptual Question 10:** Describe your new dataframe._
`r begin_button(110)`
_**Conceptual Answer 10:**_ We have a tidy long dataframe that contains pairwise comparisons contrasting sample one (p1) and sample two (p2) with corresponding metadata: deme, coi, GPS coordinates.
`r end_button()`
`r hrule()`
<br> 
<br>  

_**Code Question 14, part 2**_: Calculate within-deme IBD. Now, subset your dataframe to only contain rows where pairwise comparisons are from the same deme: `dplyr::filter(deme_p1 == deme_p2)`. Group by demes (`group_by(deme_p1)`) and use the `summarise` function to calculate the mean within-deme IBD and the mean COI (note, COI is the same within a deme). Then use the `geom_point` layer in ggplot to contrast COI and within-deme IBD calculations. 
`r begin_button(14)`
```{r}
#......................
# part 2: plot within IBD
#......................
ibd_mle_long_mtdt %>%
  dplyr::filter(deme_p1 == deme_p2) %>%
  dplyr::group_by(deme_p1) %>%
  dplyr::summarise(
    withinIBD = mean(malecotf),
    COI = unique(coimeans_p1)) %>%
  ggplot() +
  geom_point(aes(x = withinIBD, y = COI)) +
  labs(x = "Within Deme IBD", y = "Simulated Mean COI",
       caption = "Remember, COI is a poor estimate of incidence. IBD is also affected by multiple factors, including randomness.") +
  theme_classic()

```
`r end_button()`
`r hrule()`
<br> 

_**Conceptual Question 11:** Is there a correlation here between mean COI and within deme IBD?_
`r begin_button(111)`
_**Conceptual Answer 11:**_ No, but the lowest COI was associated with the greatest within deme IBD.
`r end_button()`
`r hrule()`
<br> 
<br>
_**Conceptual Question 12:** Why did our expectation of the relationship of within-deme IBD and transmission intensity not match reality?_
`r begin_button(112)`
_**Conceptual Answer 12:**_ Our expectations do not always match realized data. There are also multiple confounding variables here, including: migration and incomplete sampling.
`r end_button()`
`r hrule()`
<br> 
<br>

## Isolation by Distance
Next, we will explore the concept of isolation by distance, which is the theory that as pairs move further away in space, they should be less related (_i.e._ closer pairs are more likely to reproduce). This concept is based on spatial relationships, but can also be conceptualized as time (pairs that are separated by multiple generations of time are less likely to be related).


_**Coding Question 15, part 1**_: Calculate [greater circle distance](https://en.wikipedia.org/wiki/Great-circle_distance). First, we will read in our pre-calculated GC distances: `readRDS(data/deme_gc_dist.RDS)`. Use a `left_join` call to merge this data while making a new dataframe called `ibd_mle_long_mtdt_dist`. Now, we will "bin" our distances by converting this continuous value into a discretized form using the `cut` function:   
```
cut(x = c(ibd_mle_long_mtdt_dist$distance),
breaks = c(0, 1e-26, seq(40, 120, by = 40), Inf),
right = F, 
labels = c("Within", "40km", "80km", "120km", ">120km"))
```
<br>

`r begin_button(15)`
```{r}

#......................
# part 1
#......................
gcdist <- readRDS("data/deme_gc_dist.RDS")
ibd_mle_long_mtdt_dist <- dplyr::left_join(ibd_mle_long_mtdt, gcdist, by = c("deme_p1", "deme_p2")) %>%
  dplyr::mutate(distance = ifelse(is.na(distance), 0, distance))
ibd_mle_long_mtdt_dist$distance_cat <- 
  cut(x = c(ibd_mle_long_mtdt_dist$distance), 
      breaks = c(0, 1e-26, seq(40, 120, by = 40), Inf),
      right = F, 
      labels = c("Within", "40km", "80km", "120km", ">120km"))

```
`r end_button()`
`r hrule()`
<br> 

_**Coding Question 16, part 2**_: Using our newly created dataframe, `ibd_mle_long_mtdt_dist`, group by the `distance_cat` column created with the `cut` function above and calculate the following summaries (`summarise`): mean IBD, standard deviation IBD, standard error IBD, lower 95% CI for IBD, and upper 95% CI for IBD. You can review the power practical, part 1 for a refresher on these statistics.   
`r begin_button(16)`
```{r}
#......................
# part 2
#......................
plotdat <- ibd_mle_long_mtdt_dist %>%
  dplyr::group_by(distance_cat) %>%
  dplyr::summarise(
    n = n(),
    meanIBD = mean(malecotf),
    sdIBD = sd(malecotf),
    seIBD = sdIBD/sqrt(n),
    U95CI = meanIBD + 1.96 * seIBD,
    L95CI = meanIBD - 1.96 * seIBD) 
```
`r end_button()`
`r hrule()`
<br> 


_**Coding Question 17, part 3**_: Using the `geom_pointrange` layer in ggplot, plot the mean IBD on the y-axis and the categorized GC distance on the x-axis. For the `geom_pointrange` aesthetics, you will need to specify: `y = meanIBD, ymin = L95CI, ymax = U95CI`. 

`r begin_button(17)`
```{r}

#......................
# part 3
#......................
plotdat %>% 
  ggplot() +
  geom_pointrange(aes(x = distance_cat, y = meanIBD, ymin = L95CI, ymax = U95CI)) +
  scale_size(range = c(0, 1)) +
  labs(y = "Mean IBD", x = "GC Distance", title = "Isolation by Distance") +
  theme_classic() +
  theme(plot.title = element_text(family = "Helvetica", face = "bold", hjust = 0.5, size = 14),
        axis.title = element_text(family = "Helvetica", face = "bold", hjust = 0.5, size = 12))

```
`r end_button()`
`r hrule()`
<br> 

_**Conceptual Question 13:** How would you describe this relationship? Does it make sense?_
<br>
`r begin_button(113)`
_**Conceptual Answer 13:**_ IBD decays with increasing distance. This follows the concept of isolation by distance. 
`r end_button()`
`r hrule()`
<br> 
<br> 

### Network Analysis
We can also use networks to determine the connectivity of our paired samples. Networks helps us visualize connections that we may not expect and are a useful tool for exploratory data analysis. Additionally, we can use [community detection algorithms](https://towardsdatascience.com/community-detection-algorithms-9bd8951e7dae) to explore which samples may "cluster" together based on relatedness. One way to conceptualize community detection algorithms is to consider that networks measure "popularity" and that samples that are "cliques" should cluster together. Alternatively, a sample may be "friends" with everyone and becomes very central or important to the network. These distinctions may be helpful to determine which demes are particularly connected and may be contributing to sink-source dynamics (see [Wesolowksi _et al._ 2018](https://pubmed.ncbi.nlm.nih.gov/30333020/) for further information on sink-source dynamics).
<br>
Read this STDHA [blog](http://sthda.com/english/articles/33-social-network-analysis/136-network-analysis-and-manipulation-using-r) networks and on community detection algorithms and use the R packages: [tidygraph](https://tidygraph.data-imaginist.com/index.html) and [ggraph](https://ggraph.data-imaginist.com/) to try to generate the figure below. 

_**Coding Question 18**_: Use the `tidygraph::as_tbl_graph` function to convert our`ibd_mle_long` into an a `tbl_graph` for easier network analyses. Then calculate the compunity membership using `tidygraph::group_louvain(weights = malecotf)))` function and plot the resulting network with `ggraph::ggraph(layout = 'kk')`. Make sure to color in the nodes by community using the `geom_node_point` layer and proper aesthetic: `ggraph::geom_node_point(aes(color = community)`. 

`r begin_button(18)`
```{r}
adj_graph <- ibd_mle_long %>%
  tidygraph::as_tbl_graph(., directed = F)

ibd_mle_long %>%
  tidygraph::as_tbl_graph(., directed = F) %>%
  dplyr::mutate(community = as.factor(tidygraph::group_louvain(weights = malecotf))) %>%
  tidygraph::activate("edges") %>%
  ggraph::ggraph(layout = 'kk') +
  ggraph::geom_edge_link(aes(width = malecotf,
                             color = malecotf)) +
  ggraph::geom_node_point(aes(color = community),
                          size = 3) +
  ggraph::scale_edge_width_continuous(range = c(0, 1), guide = "none") +
  ggraph::geom_node_text(aes(label = name), repel = T) +
  ggraph::scale_edge_color_viridis("IBD", values = c(0,1), option = "plasma") +
  scale_color_brewer(palette = "Set1") +
  ggraph::theme_graph() +
  theme(legend.position = "bottom")

```
`r end_button()`
`r hrule()`
<br> 

_**Coding Question 19**_: While that graph is interesting, it may be hard to interpret given all of the low-level relatedness connections. Let's prune those and keep only connections with IBD $\geq$ 0.1. Use the `dplyr::filter` function to perform this task. 
`r begin_button(19)`
```{r}

ibd_mle_long %>%
  dplyr::filter(malecotf >= 0.1) %>% 
  tidygraph::as_tbl_graph(., directed = F) %>%
  dplyr::mutate(community = as.factor(tidygraph::group_louvain(weights = malecotf))) %>%
  tidygraph::activate("edges") %>%
  ggraph::ggraph(layout = 'kk') +
  ggraph::geom_edge_link(aes(width = malecotf,
                             color = malecotf)) +
  ggraph::geom_node_point(aes(color = community),
                          size = 3) +
  ggraph::scale_edge_width_continuous(range = c(0, 1), guide = "none") +
  ggraph::geom_node_text(aes(label = name), repel = T) +
  ggraph::scale_edge_color_viridis("IBD", values = c(0,1), option = "plasma") +
  scale_color_brewer(palette = "Set1") +
  ggraph::theme_graph() +
  theme(legend.position = "bottom")

```
`r end_button()`
`r hrule()`
<br> 


_**Conceptual Question 14:** What do you notice about the above network? Are there any isolated cliques? Are there any very "popular" samples?_
`r begin_button(114)`
_**Conceptual Answer 14:**_ All demes appear to have some degree of connectivity - albeit some demes have lower connectivity than others. For example, Deme E seems to be relatively clustered/isolated relative to the other demes (but still does have connections to the mainland). 
`r end_button()`
`r hrule()`
<br> 

## High Related Pairs
Here, we will subset to highly related pairs, defined as pairs that are at least meiotic siblings (_i.e._ share half of their genome). We will then map these between deme connections to determine if there is evidence of genetic sharing between demes. In this section, we will practice layering multiple dataframes onto a single plot to generate a figure like below. 
```{r, echo=F}
simmap <- readRDS("data/sim_map_sf.RDS")
mtdtclst <- mtdt %>%
  dplyr::select(c("deme", "longnum", "latnum")) %>%
  dplyr::filter(!duplicated(.))
# find btwn sibs
highbtwnpairs <- ibd_mle_long_mtdt %>%
  dplyr::filter(malecotf >= 0.25) %>% 
  dplyr::filter(deme_p1 != deme_p2)
# find within
withinpairs <- ibd_mle_long_mtdt %>%
  dplyr::filter(malecotf >= 0.25) %>%
  dplyr::filter(deme_p1 == deme_p2)
#plot
ggplot() +
  geom_sf(data = simmap) +
  geom_curve(data = highbtwnpairs,
             alpha = 0.5, size = 1.1,
             aes(x = longnum_p1, y = latnum_p1,
                 xend = longnum_p2, yend = latnum_p2,
                 color = malecotf), show.legend = T) +
  geom_point(data = mtdtclst, aes(x = longnum, y = latnum),
             show.legend = F, size = 3) +
  geom_point(data = withinpairs, aes(x = longnum_p1, y = latnum_p1),
             show.legend = F,
             color = "#0C73B2", shape = 15, size = 3) +
  scale_color_viridis_c("Pairwise IBD", option="plasma", direction = 1, values = c(0,1)) +
  labs(caption = "Locations that contain highly related pairs within \n the deme are colored as blue squares; \n between deme connections are shown are curved lines") +
  theme_minimal() +
  theme(panel.grid = element_blank(),
        axis.title = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank())
```


_**Coding Question 20, part 1**_: Here we will set up our data for making the map/plot. Read in the simulated map with the following function: `readRDS("data/sim_map_sf.RDS")`. Then make a condensed version of the metadata that just contains one row of coordinates for each deme. Next, make a dataframe containing highly related pairs between demes by subsetting the `ibd_mle_long_mtdt` to at least meiotic siblings: `dplyr::filter(malecotf >= 0.25)` and by excluding pairs that are from the same deme: ` dplyr::filter(deme_p1 != deme_p2)`. Finally, create a dataframe of demes that contain highly related pairs by subsetting the `ibd_mle_long_mtdt` to at least meiotic siblings: `dplyr::filter(malecotf >= 0.25)` and by including only pairs that are from the same deme: ` dplyr::filter(deme_p1 == deme_p2)`. You know have four objects ready for plotting: (1) map, (2) cluster locations, (3) highly related between deme pairs, (4) high related within deme pairs. 

`r begin_button(20)`
```{r}
#......................
# part 1
#......................
# read in map base
simmap <- readRDS("data/sim_map_sf.RDS")
mtdtclst <- mtdt %>%
  dplyr::select(c("deme", "longnum", "latnum")) %>%
  dplyr::filter(!duplicated(.))

# find btwn sibs
highbtwnpairs <- ibd_mle_long_mtdt %>%
  dplyr::filter(malecotf >= 0.25) %>% 
  dplyr::filter(deme_p1 != deme_p2)

# find within
withinpairs <- ibd_mle_long_mtdt %>%
  dplyr::filter(malecotf >= 0.25) %>%
  dplyr::filter(deme_p1 == deme_p2)
```
`r end_button()`
`r hrule()`
<br> 

_**Coding Question 21, part 2**_: We will now plot these dataframes. First make a map base using the `geom_sf` layer. Next add a layer for cluster locations using `geom_point(data = mtdtclst, aes(x = longnum, y = latnum)`. Now we will color in the demes that contain highly related pairs within: `geom_point(data = withinpairs, aes(x = longnum_p1, y = latnum_p1), color = "blue"`. Finally, we will add a connections between pairs across different demes from our highly related between pairs dataframe: `geom_curve(data = highbtwnpairs, aes(x = longnum_p1, y = latnum_p1, xend = longnum_p2, yend = latnum_p2, color = malecotf)`. Your plot contains both spatial and relatedness data in a easily communicated graph. Note, you can change the order of the layers in order to have either points or curves on top (remember, ggplot layers follow the order of the code). 

`r begin_button(21)`
```{r}
# make plot
ggplot() +
  geom_sf(data = simmap) +
  geom_curve(data = highbtwnpairs,
             alpha = 0.5, size = 1.1,
             aes(x = longnum_p1, y = latnum_p1,
                 xend = longnum_p2, yend = latnum_p2,
                 color = malecotf), show.legend = T) +
  geom_point(data = mtdtclst, aes(x = longnum, y = latnum),
             show.legend = F, size = 3) +
  geom_point(data = withinpairs, aes(x = longnum_p1, y = latnum_p1),
             show.legend = F,
             color = "#0C73B2", shape = 15, size = 3) +
  scale_color_viridis_c("Pairwise IBD", option="plasma", direction = 1, values = c(0,1)) +
  theme_minimal()

```
`r end_button()`
`r hrule()`
<br>
_**Conceptual Question 15:** What can highly related pairs tell you? How do they relate to transmission events? Can you use them to estimate genetic corridors or evidence of gene flow? Do you think there is active transmission between the mainland and island (see original study hypothesis)?_
<br>
`r begin_button(105)`
_**Conceptual Answer 15:**_ Highly related pairs provide evidence of very recent transmission events. For example, meiotic siblings (IBD $geq$ 0.5) are expected to only be separated by a single generation (under certain assumptions: infinite population size, random breeding, etc). As a result, highly related pairs provide strong evidence of active corridors of gene flow. Thus, there is evidence that there is active transmission between the main and island! Further epidemiologic data would be needed to confirm our new suspicion that the mainland is the "source" that is seeding the island ("sink").  
`r end_button()`
`r hrule()`
<br> 


# Addendum {-}
Congratulations, you have reached the end of the practical. This section contains advanced material and additional resources for interested participants. If time permits, you can explore the advanced material challenge, the challenge questions, and/or the further readings. 

### Coding Challenges 
In this section, you will have the opportunity to explore and practice the skills above. 
<br>
Imagine that there are two populations: _A_ and _B_ with similar levels of falciparum incidence. However, there are only enough public health funds to intervene on one population. You have been asked by your National Malaria Control Programme (NMCP) to determine which population to intervene on. You first conduct a "travel survey" and determine that there are a high number of people that travel from _A_ to _B_. As a result, you hypothesis that _A_ is a "source" for _B_. Using the _VCF_ below, create a series of figure that you would present to your NMCP to encourage them to interview on population _A_ instead of _B_. Make sure to calculate IBD with multiple approaches to confirm your results. 
<br>
```
# participants DO NOT need to include the quiet bit
ssvcf <- quiet(vcfR::read.vcfR("data/simulated_sink_source_ibd.vcf.gz"))
```
<br>
When finished with your figures, please ask an instructor for feedback. 
<br>



## IBD & Polyclonality
As was described in the case of `hmmIBD`, polyclonality greatly complicates IBD estimates and is an active area of research. Recent solutions include considering the malaria genome as diploid, which allows for heterozygous alleles: [`isoRelate`](https://github.com/bahlolab/isoRelate) or phasing polyclonal infections and estimating IBD from the resultant haplotypes: [deploidIBD](https://github.com/DEploid-dev/DEploid). This is an active area of research and remains a challenge within the malaria genomic epidemiology field. <br>
Below is a table of pros-cons-details of various IBD programs specified for malaria that have been peer-reviewed as of August 5, 2022. 
<br>
<br>
<br>

| **Program** 	| **Pros** 	| **Cons** 	| **Details** 	|
|---	|---	|---	|---	|
| [Inbreeding estimation](https://pubmed.ncbi.nlm.nih.gov/32355199/) 	| + Fast 	| + Assumes independent loci 	|  Model is not considering recombination blocks (backbone of IBD) 	|
| [hmmIBD](https://github.com/glipsnort/hmmIBD) 	| + Fast <br><br>+ Easy to use <br><br>+ Statistically robust <br><br>+ Cannonical program for malaria ibd <br> 	| + Specified for monoclonals 	|  Users can use in polyclonal samples, but is misspecified under model and results are typically conservative estimates of IBD 	|
| [isoRelate](https://github.com/bahlolab/isoRelate) 	| + Statistically robust <br><br>+ Handles polyclonals <br><br>+ Statistical testing for "important" loci <br> 	| + Can become computationally intensive  	|  Model assumes a "diploid" state for COI > 1, and thus makes a simplifying assumption about polyclonality 	|
| [DeploidIBD](https://github.com/DEploid-dev/DEploid) 	| + Statistically robust <br><br>+ Handles polyclonals <br><br>+ Phased sample results <br><br>+ Within-sample estimates of IBD <br> 	| + Computationally intensive 	| Model phases polyclonal samples into monoclonal samples (_i.e._ a sample with COI = 2 becomes two new phased strains: smpl1.1, smpl1.2). As part of phasing, program provides within-sample IBD. From phased sample results, users can use any existing IBD program (`hmmIBD`, `refinedIBD`, etc). Program's primary goal is phasing with within-IBD estimates provided as a "bonus". 	|

<br>
<br>


### Further Reading 
#### HMMs

Hidden Markov models (HMMs) are a common statistical approach in population genetics, and for detecting IBD. For further reading, see [Rabiner 1989](https://web.mit.edu/6.435/www/Rabiner89.pdf).  
<br>
<br>

#### Coalescent Theory

Coalescent theory is one of the central pillars of population genetics and provides a framework for how loci (genes, individuals, etc.) have been derived from a common ancestor backwards in time, classically using the assumptions of the Wright-Fisher model. 
<br>
The following are an excellent launching point for further reading:   
[Wakeley: Coalescent Theory: An Introduction](https://www.amazon.com/Coalescent-Theory-Introduction-John-Wakeley/dp/0974707759)\
[Li & Stephens: 2003 PSMC](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1462870/)\
[Li & Durbin: 2011 PSMC](https://pubmed.ncbi.nlm.nih.gov/21753753/)
